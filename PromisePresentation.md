%title: Taming the Asynchronous Beast
%author: Sushil Chhetri
%date: 2016-02-14

-> Synchronous and Asynchronous <-
=========

## Synchronous:
    * Code executes line by line
    * Values exepected in previous statement of the code is accessible in the nextline
    * Error can be thrown in the code block
    * The function can have a return statement
    * We have a callstack in which the code is executing


^
Example:
~~~~~~~~
1.    function add(a, b) {
2.        var sum = a + b;
3.
4.        if (isNaN(sum)) {
5.            throw new Error('Not a number');
6.        }
7. 
8.        return sum;
9.    }
~~~~~~~~



^
## Asynchronous
    * Code executes when the resource responds
    * Values cannot be expected to be present in the next line
    * Callstack is different
    * Errors can be thrown but not in the parent stack
    * Return statement does not make any sense


^
Example:
~~~~~~~~
1.    function add(a, b) {
2.        var sum;
3.
4.        setTimeout(function () {
5.            sum = a + b;
6.
7.            if (isNaN(sum)) {
8.                throw new Error('Not a number');
9.            }
10.        }, 100);
11.
12.        return sum;
13.    }
~~~~~~~~

-----------------------------------



















 /$$$$$$$$             /$$                                /$$$$$$            /$$ /$$ /$$                           /$$
| $$_____/            | $$                               /$$__  $$          | $$| $$| $$                          | $$
| $$       /$$$$$$$  /$$$$$$    /$$$$$$   /$$$$$$       | $$  \\__/  /$$$$$$ | $$| $$| $$$$$$$   /$$$$$$   /$$$$$$$| $$   /$$  /$$$$$$$
| $$$$$   | $$__  $$|_  $$_/   /$$__  $$ /$$__  $$      | $$       |____  $$| $$| $$| $$__  $$ |____  $$ /$$_____/| $$  /$$/ /$$_____/
| $$__/   | $$  \\ $$  | $$    | $$$$$$$$| $$  \\__/      | $$        /$$$$$$$| $$| $$| $$  \\ $$  /$$$$$$$| $$      | $$$$$$/ |  $$$$$$ 
| $$      | $$  | $$  | $$ /$$| $$_____/| $$            | $$    $$ /$$__  $$| $$| $$| $$  | $$ /$$__  $$| $$      | $$_  $$  \\____  $$
| $$$$$$$$| $$  | $$  |  $$$$/|  $$$$$$$| $$            |  $$$$$$/|  $$$$$$$| $$| $$| $$$$$$$/|  $$$$$$$|  $$$$$$$| $$ \\  $$ /$$$$$$$/
|________/|__/  |__/   \\___/   \\_______/|__/             \\______/  \\_______/|__/|__/|_______/  \\_______/ \\_______/|__/  \\__/|_______/

-----------------------------------

-> Enter callbacks <-
========

## Problems solved by callbacks
    * Work on the values generated by asynchronous code
    * Send in the errors if any


^
Example:
~~~~~
1.    function add(a, b, callback) {
2.        var sum;
3.
4.        setTimeout(function () {
5.            sum = a + b;
6.
7.            if (isNaN(sum)) {
8.                callback('Not a valid number');
9.            } else {
10.               callback(null, sum);
11.           }
12.       }, 100);
13.
14.       return sum;
15.   }
16.
17.   //function call
18.   add(1, 2, function (err, sum) {
19.       if (err) {
20.           throw new Error('Not a valid number');
21.       }
22.
23.       console.log(sum);
24.   });
~~~~~



^
## Problems not solved by callbacks
    * No stack
    * Still can't throw errors on the parent stack
    * Still can't use return



^
## Problems introduced by callbacks
    * Functions with side effects
    * _*Callback hell*_ or _*Pyramid of doom*_

> Note: Function can do 3 things (according to functional programming):
>    1. Return
>    2. Throw
>    3. Side effects (change the data or send different set of values back)

-----------------------------------

-> What is "Callback hell" or "Pyramid of doom"? <-
========

## "Callback hell" or "Pyramid of doom"

\    A *Callback hell* is nothing but a nested callbacks.





^
Example
~~~~~~~~~~~~~~~~~
1.    doAsync1(function () {
2.        doAsync2(function () {
3.            doAsync3(function () {
4.                doAsync4(function () {
5.                });
6.            });
7.        });
8.    });
~~~~~~~~~~~~~~~~~




^
## Problems faced in "Callback hell"
    * Code readability
        * Due to the indentation and level of callbacks it becomes really difficult to keep track of the callback level
    * Code Maintainence
        * Due to the multi level callbacks moving code around or changing based on requirements is difficult
    * Debugging
        * As we don't get a proper call stack it sometimes becomes really difficult to debug the code
        * Due to the multi level callbacks we need multiple error handling
    * Still can't use return statment




^
## Solutions to avoid "Callback hell"
    * Generators - Part of ES6 Specification
    * Promise
    * Async/Await - Part of ES7 Specification

-----------------------------------


















\                       /$$$$$$                                                     /$$
\                      /$$__  $$                                                   | $$
\                     | $$  \\__/  /$$$$$$  /$$$$$$$   /$$$$$$   /$$$$$$  /$$$$$$  /$$$$$$    /$$$$$$   /$$$$$$   /$$$$$$$
\                     | $$ /$$$$ /$$__  $$| $$__  $$ /$$__  $$ /$$__  $$|____  $$|_  $$_/   /$$__  $$ /$$__  $$ /$$_____/
\                     | $$|_  $$| $$$$$$$$| $$  \\ $$| $$$$$$$$| $$  \\__/ /$$$$$$$  | $$    | $$  \\ $$| $$  \\__/|  $$$$$$
\                     | $$  \\ $$| $$_____/| $$  | $$| $$_____/| $$      /$$__  $$  | $$ /$$| $$  | $$| $$       \\____  $$
\                     |  $$$$$$/|  $$$$$$$| $$  | $$|  $$$$$$$| $$     |  $$$$$$$  |  $$$$/|  $$$$$$/| $$       /$$$$$$$/
\                      \\______/  \\_______/|__/  |__/ \\_______/|__/      \\_______/   \\___/   \\______/ |__/      |_______/

-----------------------------------

-> Generators <-
=========

## Benefits of Generators
    * First Class co-routines
    * Suspend Execution context
    * small api
    * Makes code read like synchronous
    * Maintaining is easy


^
Example
~~~~~~~
1.   (function () {
2.      "use strict";
3.
4.      function* g() {
5.          yield 'd';
6.
7.          return 'a';
8.      }
9.
10.       var x = g();
11.
12.       console.log(x.next());
13.       console.log(x.next());
14.   })();
~~~~~~~





^
## Going Async with Generators
    * As we can suspend the Execution context we can wait for async task to finish
    * Generators have an api called `throw` to throw errors
    * Generators can have a return value
    * Values from previous async task can be used in the next statement




^
-> _*Lets head over to an example to see it in action*_ <-

------------------------------

Example
~~~~~~~
1.    (function () {
2.        "use strict";
3.
4.        function() {
5.            var it = g();
6.
7.            it.next();
8.
9.            function getFile(fileName) {
10.                var fs = require('fs');
11.
12.                fs.readFile(fileName, function(err, buffer) {
13.                    if (err) {
14.                        it.throw(err);
15.                    }
16.
17.                    it.next(buffer.toString());
18.                });
19.            }
20.
21.            function* g() {
22.                var result1 =
23.                    yield getFile('./PromisePresentation.md');
24.                console.log(result1);
25.                var result2 =
26.                    yield getFile('./Generator.js');
27.                console.log(result2);
28.            }
29.        }
30.    })();
~~~~~~~



^
## Caveats
    * it's still not implementated in some of the browsers
    * Need to have sort of a global instance of generator so that it is accessible by the function performing async task


^
> Note: Generator comes with one more special api ` yield* ` to handle array of data. e.g. ` yield* ['a', 'b'] `

-----------------------------------

















\                                       /$$$$$$$                                   /$$
\                                      | $$__  $$                                 |__/
\                                      | $$  \\ $$ /$$$$$$   /$$$$$$  /$$$$$$/$$$$  /$$  /$$$$$$$  /$$$$$$
\                                      | $$$$$$$//$$__  $$ /$$__  $$| $$_  $$_  $$| $$ /$$_____/ /$$__  $$
\                                      | $$____/| $$  \\__/| $$  \\ $$| $$ \\ $$ \\ $$| $$|  $$$$$$ | $$$$$$$$
\                                      | $$     | $$      | $$  | $$| $$ | $$ | $$| $$ \\____  $$| $$_____/
\                                      | $$     | $$      |  $$$$$$/| $$ | $$ | $$| $$ /$$$$$$$/|  $$$$$$$
\                                      |__/     |__/       \\______/ |__/ |__/ |__/|__/|_______/  \\_______/

--------------------------------

-> Promise to the rescue <-
=============

## Benefits of Promise
    * You can use return statement
    * Sequantially readable code
    * Call stack
    * You can throw errors
    * Completely asynchronous
    * Most Browsers implement it if not polyfills are easy to come by (e.g. Q, RSVP, When, Bluebird, Lie, etc.)
    * some very nifty apis





^
## APIs
    * Promise - Constructor
    ^
    * Static Methods
    ^
        * Promise.all
        ^
        * Promise.race
        ^
        * Promise.resolve
        ^
        * Promise.reject
        ^
    * Prototype Methods
    ^
        * Promise.prototype.then
        ^
        * Promise.prototype.catch




^
Example
~~~~~~~
1.   (function () {
2.       "use strict";
3.
4.       var p = new Promise(function(resolve, reject) {
5.               setTimeout(function() {
6.                   resolve('Resolved after 1 sec asynchronously.');
7.               }, 1000);
8.           });
9.
10.        p.then(function(res) {
11.            console.log('Logging response: ', res);
12.        });
13.
14.    })();
~~~~~~~

--------------------------------

## Catch Rejection in Promise
    * If a promise fails to fulfill it can be rejected
    * The rejected promise can be caught for error handling
    * There is a basic difference in catching error in ` then ` and in ` catch `



^
Example: Catching error with *then*
~~~~~~~~~~~
1.    (function () {
2.        var p = new Promise(function(resolve, reject) {
3.            setTimeout(function() {
4.                reject('Rejecting after 1 sec asynchronously.');
5.            }, 1000);
6.        });
7.
8.        p.then(null, function (reason) {
9.            console.log('Logging rejection with then: ', reason);
10.        });
11.    })();
~~~~~~~~~~~



^
Example: Catching error with *catch*
~~~~~~~~~~~
1.    (function () {
2.        var p = new Promise(function(resolve, reject) {
3.            setTimeout(function() {
4.                reject('Rejecting after 1 sec asynchronously.');
5.            }, 1000);
6.        });
7.
8.        p.catch(function (reason) {
9.            console.log('Logging rejection with catch: ', reason);
10.        });
11.    })();
~~~~~~~~~~~





^
## Difference in handling error with "then" and "catch"
    ^
    * ` then ` does not catch an error that occurred in the success callback of itself
    * ` catch ` catches all the error even if it occurred in success callback of a ` then `

--------------------------------

Example
~~~~~~~~~~~~~~~~
1.    (function () {
2.        var p = new Promise(function(resolve, reject) {
3.            setTimeout(function() {
4.                resolve('Resolved after 1 sec asynchronously.');
5.            }, 1000);
6.        });
7.
8.        p
9.        .then(function (res) {
11.            throw new Error('Throwing on purpose');
12.        }, function (err) {
13.            console.log('will not catch error of it\'s own success callback');
14.        })
15.        .catch(function (reason) {
16.            console.log('I\'m catching all the errors: ', reason);
17.        });
18.    })();
~~~~~~~~~~~~~~~~


^
> Note: ` catch ` should be at the end of the chain so that it can catch all the errors or use multiple catch



^
## Understanding Promise
    ^
    * Every method in promise returns a promise
    ^
    * Do not use Promise as callbacks - ` then ` can return a promise
    ^
    * If you can't use traditional loops try Promise.all
    ^
    * Always catch errors
    ^
    * Do not use side effects instead return a promise or a value or throw an error
    ^
    * Try to use Promise.resolve

    ^
        Promise.resolve(someValue).then(function() {});

^
\instead of:

        new Promise(function (resolve, reject) {resolve(someValue);}).then(function () {});

    ^
    * Promises vs Promise factories - Use factory if you don't want to execute the promises in parallel

        ^
        //This will execute parallelly
        function executeSequentially(promises) {
            var result = Promise.resolve();
            promises.forEach(function (promise) {
                result = result.then(promise);
            });
            return result;
        }

--------------------------------

        //This will not execute parallelly
        function executeSequentially(promiseFactories) {
            var result = Promise.resolve();
            promiseFactories.forEach(function (promiseFactory) {
                result = result.then(promiseFactory);
            });
            return result;
        }

        function myPromiseFactory() {
            return somethingThatCreatesAPromise();
        }

    ^
    * Promises fall through

        ^
        Promise.resolve('foo').then(Promise.resolve('bar')).then(function (result) {
            console.log(result);
        });

        ^
\same as:

        Promise.resolve('foo').then(null).then(function (result) {
            console.log(result);
        });

        ^
\Proper way:

        Promise.resolve('foo').then(function () {
            return Promise.resolve('bar');
        }).then(function (result) {
            console.log(result);
        });



^
## Promise Behaviours
    * Based on the knowledge we just gathered we can conclude that Promises have some tricky behaviour
    * It's essential we be very careful while using promise
    * Let's try to contemplate the behavior of the code examples in the next slide based on the idea we just gathered

--------------------------------

> Assumption: ` doSomething() ` and ` doSomethingElse() ` returns promises




Example 1
~~~~~~~~~~
    doSomething().then(function () {
        return doSomethingElse();
    }).then(finalHandler);
~~~~~~~~~~




^
Answer
~~~~~~~~~~~~
doSomething
|-----------------|
                  doSomethingElse(undefined)
                  |------------------|
                                     finalHandler(resultOfDoSomethingElse)
                                     |------------------|
~~~~~~~~~~~~







^
Example 2

~~~~~~~~~~~~
    doSomething().then(function () {
        doSomethingElse();
    }).then(finalHandler);
~~~~~~~~~~~~




^
Answer
~~~~~~~~~~~~
doSomething
|-----------------|
                  doSomethingElse(undefined)
                  |------------------|
                  finalHandler(undefined)
                  |------------------|
~~~~~~~~~~~~

--------------------------------




Example 3
~~~~~~~~~~~
    doSomething().then(doSomethingElse())
        .then(finalHandler);
~~~~~~~~~~~




^
Answer
~~~~~~~~~~~
doSomething
|-----------------|
doSomethingElse(undefined)
|---------------------------------|
                  finalHandler(resultOfDoSomething)
                  |------------------|
~~~~~~~~~~~




^
Example 4
~~~~~~~~~~~
    doSomething().then(doSomethingElse)
        .then(finalHandler);
~~~~~~~~~~~




^
Answer
~~~~~~~~~~~
doSomething
|-----------------|
                  doSomethingElse(resultOfDoSomething)
                  |------------------|
                                     finalHandler(resultOfDoSomethingElse)
                                     |------------------|
~~~~~~~~~~~


^
> References:
>    1. [We have a problem with promises](http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)
>    2. To see the above example in action goto [http://jsbin.com/tuqukakawo/1/edit?js,console,output](http://jsbin.com/tuqukakawo/1/edit?js,console,output)

--------------------------------















\                 /$$$$$$                                                /$$ /$$$$$$                          /$$   /$$
\                /$$__  $$                                              /$$//$$__  $$                        |__/  | $$
\               | $$  \\ $$  /$$$$$$$ /$$   /$$ /$$$$$$$   /$$$$$$$     /$$/| $$  \\ $$ /$$  /$$  /$$  /$$$$$$  /$$ /$$$$$$
\               | $$$$$$$$ /$$_____/| $$  | $$| $$__  $$ /$$_____/    /$$/ | $$$$$$$$| $$ | $$ | $$ |____  $$| $$|_  $$_/
\               | $$__  $$|  $$$$$$ | $$  | $$| $$  \\ $$| $$         /$$/  | $$__  $$| $$ | $$ | $$  /$$$$$$$| $$  | $$
\               | $$  | $$ \\____  $$| $$  | $$| $$  | $$| $$        /$$/   | $$  | $$| $$ | $$ | $$ /$$__  $$| $$  | $$ /$$
\               | $$  | $$ /$$$$$$$/|  $$$$$$$| $$  | $$|  $$$$$$$ /$$/    | $$  | $$|  $$$$$/$$$$/|  $$$$$$$| $$  |  $$$$/
\               |__/  |__/|_______/  \\____  $$|__/  |__/ \\_______/|__/     |__/  |__/ \\_____/\\___/  \\_______/|__/   \\___/
\                                    /$$  | $$
\                                   |  $$$$$$/
\                                    \\______/

--------------------------------

-> Async/Await <-
==========

## Benefits of Async/Await
    * Makes code completely synchronous from readability point of view
    * samll apis
    * syntactical sugaring
    * Can use return statements
    * can use try catch blocks
    * Awesome Call stack




^
Example
~~~~~~~~~~~~~~~~~~
1.    (function () {
2.        "use strict";
3.
4.        async function combineInfo() {
5.            try {
6.                var result1 = await doAsync(); //ajax call
7.
8.                console.log(result1);
9.
10.                var result2 = await doAsync(param); //another ajax call
11.
12.                console.log(result2);
13.            } catch (e) {
14.                console.log('Caught an exception: ', e.message);
15.            }
16.        }
17.    })();
~~~~~~~~~~~~~~~~~~



^
## Disadvantage
    * ES7 specification
    * Browsers have not yet implemented it
    * Need transpilers to use it today (e.g. Babel, Regenarator)
    * Very tricky to use it with Array.prototype.forEach, Array.prototype.map, etc.

--------------------------------












\                                                  /$$$$$$             /$$$$$$
\                                                 /$$__  $$           /$$__  $$
\                                                | $$  \\ $$ /$$$$$$$ | $$  \\ $$
\                                                | $$  | $$| $$__  $$| $$$$$$$$
\                                                | $$  | $$| $$  \\ $$| $$__  $$
\                                                | $$/$$ $$| $$  | $$| $$  | $$
\                                                |  $$$$$$/| $$  | $$| $$  | $$
\                                                 \\____ $$$|__/  |__/|__/  |__/
\                                                      \\__/
\                                                --------------------------------
\                 /$$$$$$$$ /$$                           /$$                                           /$$ /$$ /$$
\                |__  $$__/| $$                          | $$                                          | $$| $$| $$
\                   | $$   | $$$$$$$   /$$$$$$  /$$$$$$$ | $$   /$$       /$$   /$$  /$$$$$$  /$$   /$$| $$| $$| $$
\                   | $$   | $$__  $$ |____  $$| $$__  $$| $$  /$$/      | $$  | $$ /$$__  $$| $$  | $$| $$| $$| $$
\                   | $$   | $$  \\ $$  /$$$$$$$| $$  \\ $$| $$$$$$/       | $$  | $$| $$  \\ $$| $$  | $$|__/|__/|__/
\                   | $$   | $$  | $$ /$$__  $$| $$  | $$| $$_  $$       | $$  | $$| $$  | $$| $$  | $$
\                   | $$   | $$  | $$|  $$$$$$$| $$  | $$| $$ \\  $$      |  $$$$$$$|  $$$$$$/|  $$$$$$/ /$$ /$$ /$$
\                   |__/   |__/  |__/ \\_______/|__/  |__/|__/  \\__/       \\____  $$ \\______/  \\______/ |__/|__/|__/
\                                                                         /$$  | $$
\                                                                        |  $$$$$$/
\                                                                         \\______/
